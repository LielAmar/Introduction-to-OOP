lielamar
211771993

Question 1:
  New classes:
    - CameraChangeStrategy:
      - Added a class that extends CollisionStrategy and adds a functionality of changing
        the game camera to focus on the ball until it hits 4 items.
        We track the ball hits through the usage of TrackedGameObject (see #Utils.TrackedGameObject).
        Once we reached the limit of 4 hits, we reset the camera (see #Changes.BrickerGameManager)

    - DoublePowerupStrategy:
      - Added a class that extends CollisionStrategy and adds a functionality of having multiple
        power-ups (up to 3).
        We use the StrategyRandomizer to randomly select the relevant
        power-ups (see #New classes.StrategyRandomizer).

    - ExtraLifeStrategy:
      - Added a class that extends CollisionStrategy and adds a functionality of restoring a heart.
        We create a new Heart object (see New classes.Heart) with a downwards velocity.

    - ExtraPaddleStrategy:
      - Added a class that extends CollisionStrategy and adds a functionality of adding another paddle.
        We create a new FinitePaddle object (see New classes.FinitePaddle) with a limit of 3 hits.

    - ExtraPucksStrategy:
      - Added a class that extends CollisionStrategy and adds a functionality of adding more pucks.
        We create a new Puck(s) object (see New classes.Puck).

    - StrategyRandomizer:
      - Added a class that can randomly select between 6 (or 5) different strategies.

    - FinitePaddle:
      - Added a class that extends Paddle and adds a tracker to its lives.
        The BrickerGameManager then checks if we need to remove
        the extra paddle (see #Changes.BrickerGameManager)

    - Heart:
      - Added a class that extends GameObject and handles a single heart with or without a velocity.
        If it hits a paddle and it has a lifeCounter, it marks itself as "used" for the BrickerGameManager
        to be able to know whether to remove it (see #Changes.BrickerGameManager)

    - Puck:
      - Added a class that extends Ball and adds a functionality of a puck. It should have an initial
        velocity of a downwards diagonal

  Changes:
    - Ball:
      - Changed ball to extand TrackedGameObject instead of GameObject, to be able to track hits.
        The BrickerGameManager then uses this counter to know whether to reset the camera (see
        #Changes.BrickerGameManager)

    - Brick:
      - Added a new constructor to be able to receive an array of strategies.

    - BrickerGameManager:
      - Added functions to check whether we should remove:
        - Pucks
        - Extra paddle
        - Falling heart
      - Added functionality to randomaly choose a strategy for each brick it creates
      - Changed livesCounter to be a BoundedCounter (see #Utils.BoundedCounter) so we don't go past
        4 lives.

  Utils:
    - TrackedGameObject:
      - A game object with added functionality to track anything we'd like.
        Our use cases are:
        - Track the ball hits with other objects

    - BoundedCounter:
      - A counter that adds an upper bound so we can't increment past a certain limit.
        Out use cases are:
        - We create the livesCounter to be a BoundedCounter with an upper bound of 4.
          This way, when taking a falling heart, we don't go past 4 lives, without any other checks.


Question 2:
  I have chosen to use a modified version of a Factory for the StrategyRandomizer.
  The reason is that I don't need to create any instances according to an input but rather choose
  a strategy randomly.

  We also decided to use inhertiance in BoundedCounter and an abstract class that extends GameObject
  to be able to track and prevent/allow some functionalities without the need of adding spaghetti code

Question 3:
  To limit the double powerup strategy to have only 3 items, we've created a
  dynamic size array (linkedlist) and kept on adding new strategies as long as we roll doublepowerups
  and we didn't hit the limit of 3 items.

Question 4:
  To be able to hold more than a single strategy, we changed brick to hold an array of strategies instead.
  Once a collision occurs, we execute all strategies.